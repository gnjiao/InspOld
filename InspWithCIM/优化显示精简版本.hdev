<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.1.0">
<procedure name="main">
<interface/>
<body>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 600, 400, 'black', WindowHandle1)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_open_window (0, 768, 600, 400, 'black', WindowHandle2)</l>
<l>dev_set_draw ('margin')</l>
<c></c>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<c></c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,2]" as_ord="1">list_files ('E:/项目/设备/产品/巡边检/image/ng', ['files','follow_links','recursive'], ImageFiles)</l>
<l>tuple_regexp_select (ImageFiles, ['\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$','ignore_case'], ImageFiles)</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,2]" as_ord="1">for Index := 0 to |ImageFiles| - 1 by 1</l>
<l>    dev_update_window('off')</l>
<c>    </c>
<l>read_image (Image,ImageFiles[Index])</l>
<c></c>
<c>    *不实时更新图像</c>
<c></c>
<l>    get_image_size (Image, WidthImage, HeightImage)</l>
<c>        *全局ROI框</c>
<l>    Column:=WidthImage/2</l>
<l>    Row:=HeightImage/2</l>
<l>    Phi1:=-1.57</l>
<l>    Length2:=WidthImage/2-1</l>
<l>    Length1:=HeightImage/2-1</l>
<c>    </c>
<c>    </c>
<c>    *矩形2方法</c>
<l>    dev_set_window (WindowHandle1)</l>
<l>    threshold (Image, Region40, 30, 255)</l>
<l>    smallest_rectangle2 (Region40, RowSm2, ColumnSm2, PhiSm2, Length1Sm2, Length2Sm2)</l>
<l>    gen_rectangle2 (Rectangle40, RowSm2, ColumnSm2, PhiSm2, Length1Sm2, Length2Sm2)</l>
<l>    threshold (Image, Region45, 60, 255)</l>
<l>    difference (Rectangle40, Region45, RegionDifference1)</l>
<l>     dev_display (Image)</l>
<l>     dev_display (RegionDifference1)</l>
<c>    </c>
<l>    dev_set_window (WindowHandle2)</l>
<c>    *求M直线的方法-同样需要对原图进行预处理</c>
<l>     connection (Region40, ConnectedRegions)</l>
<l>    opening_rectangle1 (Region40, RegionClosing, 15, 15)</l>
<c>    *对二值化的图形，求凸包</c>
<l>    shape_trans (RegionClosing, RegionTrans1, 'convex')</l>
<c>    *最小矩形1-生成矩形测量ROI</c>
<l>    smallest_rectangle1 (RegionTrans1, RowR1, ColumnR1, RowR2, ColumnR2)</l>
<c>    *对视野中边角太小的图片，直接略过，默认OK？</c>
<l>    if((ColumnR2-ColumnR1)&lt;WidthImage/8)</l>
<l> *       continue</l>
<l>    endif</l>
<c>    *获得边界图像-方便后续提取边缘</c>
<l>    boundary (RegionTrans1, RegionBorder, 'inner_filled')</l>
<l>    fill_up_shape (RegionBorder, RegionFillUp, 'area', 1, 999999)</l>
<l>     difference (Region40,RegionFillUp, RegionDifference2)</l>
<l>     difference (RegionFillUp,Region40,RegionDifference3)</l>
<l>     connection (RegionDifference3, ConnectedRegions)</l>
<l>     smallest_rectangle2 (ConnectedRegions, Row4, Column4, Phi, Length11, Length21)</l>
<l>     gen_rectangle2 (Rectangle, Row4, Column4, Phi, Length11, Length21)</l>
<l>     region_to_bin (RegionTrans1, BinImage, 255, 0, WidthImage, HeightImage)</l>
<c>    *拟合边缘线段</c>
<l>    FitRegionEdge (RegionBorder, RowR1, ColumnR1, RowR2, ColumnR2, WidthImage, RowBegin1, ColBegin1, RowEnd1, ColEnd1, SideRowBegin, SideColBegin, SideRowEnd, SideColEnd, side)</l>
<c>    </c>
<l>     dev_display (Image)</l>
<c>    *显示拟合出的边缘线段</c>
<l>     disp_line (WindowHandle2, RowBegin1, ColBegin1, RowEnd1, ColEnd1)</l>
<l>     if(side!=0)</l>
<l>         disp_line (WindowHandle2, SideRowBegin, SideColBegin, SideRowEnd, SideColEnd)</l>
<l>     endif</l>
<c>    </c>
<l>     stop ()</l>
<c>    *根据边缘线段求得处理区域</c>
<l>    switch (side)</l>
<l>    case 0:</l>
<l>        intersection_lines (RowBegin1, ColBegin1, RowEnd1, ColEnd1, 0, 0, HeightImage, 0, Row1, Column1, IsOverlapping1)</l>
<l>        intersection_lines (RowBegin1, ColBegin1, RowEnd1, ColEnd1, 0, WidthImage, HeightImage, WidthImage, Row2, Column2, IsOverlapping2)</l>
<l>        gen_contour_polygon_xld (Contour, [Row1,Row2,HeightImage,HeightImage], [Column1,Column2,WidthImage,0])</l>
<l>    break</l>
<c>          </c>
<l>    case 1:</l>
<l>        intersection_lines (RowBegin1, ColBegin1, RowEnd1, ColEnd1, SideRowBegin, SideColBegin, SideRowEnd, SideColEnd, Row1, Column1, IsOverlapping1)</l>
<l>        intersection_lines (RowBegin1, ColBegin1, RowEnd1, ColEnd1, 0, WidthImage, HeightImage, WidthImage, Row2, Column2, IsOverlapping2)</l>
<l>        intersection_lines (SideRowBegin, SideColBegin, SideRowEnd, SideColEnd, HeightImage, 0, HeightImage, WidthImage, Row3, Column3, IsOverlapping3)</l>
<l>        gen_contour_polygon_xld (Contour, [Row1,Row2,HeightImage,Row3], [Column1,Column2,WidthImage,Column3])</l>
<l>    break</l>
<c>       </c>
<l>    case 2:</l>
<l>        intersection_lines (RowBegin1, ColBegin1, RowEnd1, ColEnd1, 0, 0, HeightImage, 0, Row1, Column1, IsOverlapping1)</l>
<l>        intersection_lines (RowBegin1, ColBegin1, RowEnd1, ColEnd1, SideRowBegin, SideColBegin, SideRowEnd, SideColEnd, Row2, Column2, IsOverlapping2)</l>
<l>        intersection_lines (SideRowBegin, SideColBegin, SideRowEnd, SideColEnd, HeightImage, 0, HeightImage, WidthImage, Row3, Column3, IsOverlapping3)</l>
<l>        gen_contour_polygon_xld (Contour, [Row1,Row2,Row3,HeightImage], [Column1,Column2,Column3,0])</l>
<l>    break</l>
<l>    endswitch</l>
<c>    </c>
<l>    gen_region_contour_xld (Contour, Region, 'filled')</l>
<l>    stop ()</l>
<c>    *为什么要做这个intersection</c>
<l>     intersection (Rectangle40, Region, RegionIntersection)</l>
<l>    threshold (Image, Region45, 45, 255)</l>
<l>    difference (Region, Region45, RegionDifference)</l>
<c>    *只显示边角图片</c>
<l>*     if(side=1 or side=2)</l>
<l>           dev_set_window (WindowHandle2)</l>
<l>           dev_display (Image)</l>
<l>           dev_display (RegionDifference)</l>
<l>         *  dev_disp_text (Index, 'window', 100, 100, 'red', [], [])</l>
<l>           dev_set_window (WindowHandle1)</l>
<l>           dev_display (Image)</l>
<l>           dev_display (RegionDifference1)</l>
<l>         *  dev_disp_text (Index, 'window', 100, 100, 'red', [], [])</l>
<l>*     endif</l>
<c></c>
<l>     stop ()</l>
<c>        *不实时更新图像</c>
<l>    dev_update_window('on')</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[3,1]" as_ord="1">endfor</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="MStrightLine">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="RowCenter" base_type="ctrl" dimension="0"/>
<par name="ColCenter" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
<par name="Length1" base_type="ctrl" dimension="0"/>
<par name="Length2" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowBegin" base_type="ctrl" dimension="0"/>
<par name="ColBegin" base_type="ctrl" dimension="0"/>
<par name="RowEnd" base_type="ctrl" dimension="0"/>
<par name="ColEnd" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>RoiNum := 10</l>
<l>RowEdges := []</l>
<l>ColumnEdges := []</l>
<l>RoiLength1 := Length1</l>
<l>RoiLength2 := Length2/RoiNum</l>
<c></c>
<l>sigma := 1</l>
<l>th := 30</l>
<l>Polarity := 'positive'</l>
<l>Select := 'first'</l>
<c></c>
<l>for Index := 1 to RoiNum by 1</l>
<l>    RoiRowCenter := RowCenter</l>
<l>    RoiColCenter := ColCenter-Length2+Length2*2/RoiNum*Index-RoiLength2</l>
<l>    gen_rectangle2 (Rectangle, RoiRowCenter, RoiColCenter, Phi, RoiLength1, RoiLength2)</l>
<l>    gen_measure_rectangle2 (RoiRowCenter, RoiColCenter, Phi, RoiLength1, RoiLength2, Width, Height, 'nearest_neighbor', MeasureHandle)</l>
<l>    measure_pos (Image, MeasureHandle, sigma, th, Polarity, Select, RowEdge, ColumnEdge, Amplitude, Distance)</l>
<l>    RowEdges := [RowEdges,RowEdge]</l>
<l>    ColumnEdges := [ColumnEdges,ColumnEdge]</l>
<c></c>
<l>endfor</l>
<c></c>
<l>gen_contour_polygon_xld (ContourEdge, RowEdges, ColumnEdges)</l>
<l>tuple_length (RoiRowCenter, Length)</l>
<l>* if (Length&gt;1)</l>
<c></c>
<l>    fit_line_contour_xld (ContourEdge, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>* else</l>
<l>*     RowBegin := RowEdges</l>
<l>*     ColBegin := ColumnEdges</l>
<l>*     RowEnd := RowEdges</l>
<l>*     ColEnd := ColumnEdges</l>
<l>* endif</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="MStrightLine">
<parameters>
<parameter id="ColBegin"/>
<parameter id="ColCenter"/>
<parameter id="ColEnd"/>
<parameter id="Height"/>
<parameter id="Image"/>
<parameter id="Length1"/>
<parameter id="Length2"/>
<parameter id="Phi"/>
<parameter id="RowBegin"/>
<parameter id="RowCenter"/>
<parameter id="RowEnd"/>
<parameter id="Width"/>
</parameters>
</docu>
</procedure>
<procedure name="MXldRect2">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Phi1" base_type="ctrl" dimension="0"/>
<par name="Length1" base_type="ctrl" dimension="0"/>
<par name="Length2" base_type="ctrl" dimension="0"/>
<par name="WidthImage" base_type="ctrl" dimension="0"/>
<par name="HeightImage" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowRect" base_type="ctrl" dimension="0"/>
<par name="ColRect" base_type="ctrl" dimension="0"/>
<par name="PhiRect" base_type="ctrl" dimension="0"/>
<par name="Length1Rect" base_type="ctrl" dimension="0"/>
<par name="Length2Rect" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>    MStrightLine (Image, Row, Column, Phi1, Length1, Length2, WidthImage, HeightImage, RowRect, ColRect, PhiRect, Length1Rect)</l>
<l>return ()</l>
</body>
<docu id="MXldRect2">
<parameters>
<parameter id="ColRect"/>
<parameter id="Column"/>
<parameter id="HeightImage"/>
<parameter id="Image"/>
<parameter id="Length1"/>
<parameter id="Length1Rect"/>
<parameter id="Length2"/>
<parameter id="Length2Rect"/>
<parameter id="Phi1"/>
<parameter id="PhiRect"/>
<parameter id="Row"/>
<parameter id="RowRect"/>
<parameter id="WidthImage"/>
</parameters>
</docu>
</procedure>
<procedure name="FitRegionEdge">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="RowR1" base_type="ctrl" dimension="0"/>
<par name="ColumnR1" base_type="ctrl" dimension="0"/>
<par name="RowR2" base_type="ctrl" dimension="0"/>
<par name="ColumnR2" base_type="ctrl" dimension="0"/>
<par name="WidthImage" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowBegin" base_type="ctrl" dimension="0"/>
<par name="ColBegin" base_type="ctrl" dimension="0"/>
<par name="RowEnd" base_type="ctrl" dimension="0"/>
<par name="ColEnd" base_type="ctrl" dimension="0"/>
<par name="SideRowBegin" base_type="ctrl" dimension="0"/>
<par name="SideColBegin" base_type="ctrl" dimension="0"/>
<par name="SideRowEnd" base_type="ctrl" dimension="0"/>
<par name="SideColEnd" base_type="ctrl" dimension="0"/>
<par name="side" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>RoiNum := 20</l>
<l>RowEdges := []</l>
<l>ColumnEdges := []</l>
<l>MRoiWidth:=(ColumnR2-ColumnR1)/RoiNum</l>
<c></c>
<c>*测量矩形竖直方向内缩值</c>
<l>MRegionErosionV:=50</l>
<c>*测量矩形水平方向内缩值</c>
<l>MRegionErosionH:=2</l>
<c></c>
<l>* gen_empty_obj (Rectangles)</l>
<l>Row1s:=[]</l>
<l>Row2s:=[]</l>
<l>Col1s:=[]</l>
<l>Col2s:=[]</l>
<l>for Index := 1 to RoiNum by 1</l>
<c>    *分段求交集</c>
<l>    if(RowR1&gt;MRegionErosionV)</l>
<l>        Row1s:=[Row1s,RowR1-MRegionErosionV]</l>
<l>    else</l>
<l>        Row1s:=[Row1s,1]</l>
<l>    endif</l>
<l>    if(RowR2-RowR1&gt;MRegionErosionV)</l>
<l>        Row2s:=[Row2s,RowR2-MRegionErosionV]</l>
<l>    else</l>
<l>        Row2s:=[Row2s,RowR2-1]</l>
<l>    endif</l>
<l>    Col1s:=[Col1s,ColumnR1+(Index-1)*MRoiWidth + MRegionErosionH]</l>
<l>    Col2s:=[Col2s,ColumnR1+Index*MRoiWidth-MRegionErosionH]</l>
<l>endfor</l>
<c></c>
<l>    gen_rectangle1 (Rectangles,Row1s ,Col1s, Row2s,Col2s )</l>
<l>    intersection (Rectangles, Region, RegionIntersection)</l>
<c>    *SelectShape是否有必要时具体情形而定--耗时稍长</c>
<l>*     select_shape (RegionIntersection, SelectedRegions, 'area', 'and', 1, 99999)</l>
<l>    area_center (RegionIntersection, Areas, RowEdges, ColumnEdges)</l>
<l>    gen_contour_polygon_xld (ContourEdge, RowEdges, ColumnEdges)</l>
<c>    *拟合直线，拟合时，删除了第一个点和最后一个点-主要是应对拍摄的矩形边角的情况</c>
<l>    fit_line_contour_xld (ContourEdge, 'tukey', -1, 1, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<c></c>
<c>*再判定是否需要拟合左右边缘</c>
<c></c>
<l>    SideRow1s:=[]</l>
<l>    SideRow2s:=[]</l>
<l>    SideColumn1s:=[]</l>
<l>    SideColumn2s:=[]</l>
<l>    MRoiHeight:=(RowR2-RowR1)/RoiNum</l>
<l>    side:=0</l>
<c>    *左边间隙大于右边</c>
<l>    if(ColumnR1&gt;(WidthImage-ColumnR2))</l>
<c>        *左边间隙为玻璃边角</c>
<l>        if(ColumnR1&gt;2)</l>
<l>            for Index := 1 to RoiNum by 1</l>
<c>                *分段求交集</c>
<l>                SideRow1s:=[SideRow1s,RowR1+(Index-1)*MRoiHeight + MRegionErosionH]</l>
<l>                SideRow2s:=[SideRow2s,RowR1+Index*MRoiHeight + MRegionErosionH]</l>
<c>                </c>
<l>                if(ColumnR1&gt;MRegionErosionV)</l>
<l>                    SideColumn1s:=[SideColumn1s,ColumnR1-MRegionErosionV]</l>
<l>                else</l>
<l>                    SideColumn1s:=[SideColumn1s,1]</l>
<l>                endif</l>
<l>                if(ColumnR2-ColumnR1&gt;MRegionErosionV)</l>
<l>                    SideColumn2s:=[SideColumn2s,ColumnR2-MRegionErosionV]</l>
<l>                else</l>
<l>                    SideColumn2s:=[SideColumn2s,ColumnR2-1]</l>
<l>                endif</l>
<l>            endfor</l>
<l>            gen_rectangle1 (SideRectangles,SideRow1s ,SideColumn1s, SideRow2s,SideColumn2s )</l>
<l>            intersection (SideRectangles, Region, SideRegionIntersection)</l>
<c>            *SelectShape是否有必要时具体情形而定--耗时稍长</c>
<l>*           select_shape (RegionIntersection, SelectedRegions, 'area', 'and', 1, 99999)</l>
<l>            area_center (SideRegionIntersection, SideAreas, SideRowEdges, SideColumnEdges)</l>
<l>            gen_contour_polygon_xld (SideContourEdge, SideRowEdges, SideColumnEdges)</l>
<c>            *拟合直线，拟合时，删除了第一个点和最后一个点-主要是应对拍摄的矩形边角的情况</c>
<l>            fit_line_contour_xld (SideContourEdge, 'tukey', -1, 1, 5, 2, SideRowBegin, SideColBegin, SideRowEnd, SideColEnd, Nr, Nc, Dist)</l>
<l>            side:=1</l>
<l>        endif</l>
<l>    else</l>
<c>        *右边间隙为玻璃边角</c>
<l>        if(WidthImage-ColumnR2&gt;2)</l>
<l>            for Index := 1 to RoiNum by 1</l>
<c>                *分段求交集</c>
<l>                SideRow1s:=[SideRow1s,RowR1+(Index-1)*MRoiHeight + MRegionErosionH]</l>
<l>                SideRow2s:=[SideRow2s,RowR1+Index*MRoiHeight + MRegionErosionH]</l>
<c>                </c>
<l>                if(ColumnR2-ColumnR1&gt;MRegionErosionV)</l>
<l>                    SideColumn1s:=[SideColumn1s,ColumnR1+MRegionErosionV]</l>
<l>                else</l>
<l>                    SideColumn1s:=[SideColumn1s,ColumnR1+1]</l>
<l>                endif</l>
<l>                if(WidthImage-ColumnR2&gt;MRegionErosionV)</l>
<l>                    SideColumn2s:=[SideColumn2s,ColumnR2+MRegionErosionV]</l>
<l>                else</l>
<l>                    SideColumn2s:=[SideColumn2s,WidthImage-1]</l>
<l>                endif</l>
<l>            endfor</l>
<l>            gen_rectangle1 (SideRectangles,SideRow1s ,SideColumn1s, SideRow2s,SideColumn2s )</l>
<l>            intersection (SideRectangles, Region, SideRegionIntersection)</l>
<c>            *SelectShape是否有必要时具体情形而定--耗时稍长</c>
<l>*           select_shape (RegionIntersection, SelectedRegions, 'area', 'and', 1, 99999)</l>
<l>            area_center (SideRegionIntersection, SideAreas, SideRowEdges, SideColumnEdges)</l>
<l>            gen_contour_polygon_xld (SideContourEdge, SideRowEdges, SideColumnEdges)</l>
<c>            *拟合直线，拟合时，删除了第一个点和最后一个点-主要是应对拍摄的矩形边角的情况</c>
<l>            fit_line_contour_xld (SideContourEdge, 'tukey', -1, 1, 5, 2, SideRowBegin, SideColBegin, SideRowEnd, SideColEnd, Nr, Nc, Dist)</l>
<l>            side:=2</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="FitRegionEdge">
<parameters>
<parameter id="ColBegin"/>
<parameter id="ColEnd"/>
<parameter id="ColumnR1"/>
<parameter id="ColumnR2"/>
<parameter id="Region"/>
<parameter id="RowBegin"/>
<parameter id="RowEnd"/>
<parameter id="RowR1"/>
<parameter id="RowR2"/>
<parameter id="SideColBegin"/>
<parameter id="SideColEnd"/>
<parameter id="SideRowBegin"/>
<parameter id="SideRowEnd"/>
<parameter id="WidthImage"/>
<parameter id="side"/>
</parameters>
</docu>
</procedure>
</hdevelop>
